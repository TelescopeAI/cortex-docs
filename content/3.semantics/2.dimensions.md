---
navigation:
  icon: i-lucide-pie-chart
title: Dimensions
description: Categorical attributes for grouping and analyzing measures, representing the ways you slice and dice your data.
---

![Dimensions Overview Diagram](placeholder://dimensions-overview-diagram.png)
*Diagram showing how dimensions enable data grouping and filtering*

## Use Cases

Dimensions are used for:
- **Geographic Analysis**: Group by country, region, city
- **Time-based Analysis**: Group by date, month, quarter, year
- **User Segmentation**: Group by user type, subscription tier, demographics
- **Product Analysis**: Group by category, brand, price range
- **Performance Analysis**: Group by device, browser, operating system

## Syntax

**Type:** `SemanticDimension`

List of categorical attributes by which the measures can be grouped. Dimensions define how data should be categorized and filtered.

```json
{
    "dimensions": [
        {
            "name": "user_segment",
            "description": "User segmentation category",
            "query": "segment_type",
            "table": "users",
            "formatting": [
                {
                    "name": "segment_display",
                    "type": "format",
                    "format_type": "custom",
                    "format_string": "Segment: {value}"
                }
            ]
        }
    ]
}
```

## Parameters

### name

**Type:** `str`  
**Required:** Yes

Unique identifier name for this dimension. Used to reference the dimension in queries and API calls.

```json
{
    "name": "user_segment"
}
```

### description

**Type:** `Optional[str]`  
**Default:** `None`  
**Required:** No

Human-readable explanation of what this dimension represents. Helps other developers understand the categorization logic.

```json
{
    "description": "User segmentation based on subscription tier and usage patterns"
}
```

### query

**Type:** `str`  
**Required:** Yes

Column name or SQL expression that defines this dimension. Used in query generation to specify the data field for grouping.

```json
{
    "query": "segment_type"
}
```

### table

**Type:** `Optional[str]`  
**Default:** `None`  
**Required:** No

Source table or view where this dimension's data resides. Specifies the primary data source for the dimension.

```json
{
    "table": "users"
}
```

### formatting

**Type:** `Optional[List[OutputFormat]]`  
**Default:** `None`  
**Required:** No

Array of OutputFormat objects for display transformation. Allows you to format dimension values for better presentation.

```json
{
    "formatting": [
        {
            "name": "segment_display",
            "type": "format",
            "format_type": "custom",
            "format_string": "Segment: {value}"
        }
    ]
}
```

## Patterns

### Geographic Dimensions

```json
{
    "dimensions": [
        {
            "name": "country",
            "description": "User country",
            "query": "country_code",
            "table": "users"
        },
        {
            "name": "region",
            "description": "Geographic region",
            "query": "CASE WHEN country_code IN ('US', 'CA', 'MX') THEN 'North America' ELSE 'Other' END",
            "table": "users"
        }
    ]
}
```

### Time Dimensions

```json
{
    "dimensions": [
        {
            "name": "year",
            "description": "Order year",
            "query": "EXTRACT(YEAR FROM created_at)",
            "table": "orders"
        },
        {
            "name": "month",
            "description": "Order month",
            "query": "TO_CHAR(created_at, 'YYYY-MM')",
            "table": "orders"
        },
        {
            "name": "day_of_week",
            "description": "Day of the week",
            "query": "TO_CHAR(created_at, 'Day')",
            "table": "orders"
        }
    ]
}
```

### User Segmentation

```json
{
    "dimensions": [
        {
            "name": "user_tier",
            "description": "Subscription tier",
            "query": "subscription_tier",
            "table": "users",
            "formatting": [
                {
                    "name": "tier_display",
                    "type": "format",
                    "format_type": "custom",
                    "format_string": "{value} Tier"
                }
            ]
        },
        {
            "name": "age_group",
            "description": "User age group",
            "query": "CASE WHEN age < 25 THEN '18-24' WHEN age < 35 THEN '25-34' ELSE '35+' END",
            "table": "users"
        }
    ]
}
```

### Product Categories

```json
{
    "dimensions": [
        {
            "name": "product_category",
            "description": "Product category",
            "query": "category_name",
            "table": "products"
        },
        {
            "name": "price_range",
            "description": "Price range",
            "query": "CASE WHEN price < 50 THEN 'Budget' WHEN price < 200 THEN 'Mid-range' ELSE 'Premium' END",
            "table": "products"
        }
    ]
}
```

## Advanced Techniques

### Calculated Dimensions

Create dimensions based on complex calculations:

```json
{
    "name": "customer_lifetime_value_tier",
    "description": "Customer value tier based on total spend",
    "query": "CASE WHEN total_spend > 10000 THEN 'High Value' WHEN total_spend > 1000 THEN 'Medium Value' ELSE 'Low Value' END",
    "table": "customers"
}
```

### Hierarchical Dimensions

Create parent-child relationships:

```json
{
    "dimensions": [
        {
            "name": "region",
            "description": "Geographic region",
            "query": "region_name",
            "table": "locations"
        },
        {
            "name": "country",
            "description": "Country within region",
            "query": "country_name",
            "table": "locations"
        },
        {
            "name": "city",
            "description": "City within country",
            "query": "city_name",
            "table": "locations"
        }
    ]
}
```

## Best Practices

1. **Use Clear Naming**: Choose descriptive names that clearly indicate what the dimension represents
2. **Add Descriptions**: Always include descriptions to explain the categorization logic
3. **Consider Cardinality**: Be mindful of high-cardinality dimensions that might create too many groups
4. **Use Formatting**: Apply appropriate formatting for better data presentation
5. **Optimize Queries**: Use efficient column references and avoid complex calculations when possible

## Performance

- **Indexing**: Ensure dimension columns are properly indexed for fast grouping
- **Cardinality**: High-cardinality dimensions can impact query performance
- **Data Types**: Use appropriate data types for better storage and query efficiency

## Video Tutorial

[![Dimensions Configuration Tutorial](placeholder://video-thumbnail.png)](placeholder://dimensions-tutorial-video.mp4)
*Video: How to set up and configure dimensions in the Cortex dashboard*

## Dashboard Examples

![Dimensions in Dashboard](placeholder://dimensions-dashboard-example.png)
*Example showing how dimensions appear in the Cortex dashboard interface*

## Related Topics

- [Measures Configuration](./2.measures.md) - Learn about the quantitative metrics you can group
- [Joins Configuration](./4.joins.md) - Connect data from multiple tables
- [Filters Configuration](./6.filters.md) - Filter data based on dimension values
- [Metric Configuration](./1.metric-configuration.md) - Complete metric setup guide
